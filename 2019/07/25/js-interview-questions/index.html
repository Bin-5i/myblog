<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaScript 常用面试题集 | Bin 博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript 常用面试题集</h1><a id="logo" href="/.">Bin 博客</a><p class="description">一名资深IT开发者.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript 常用面试题集</h1><div class="post-meta">Jul 25, 2019</div><div class="post-content"><p>面试题</p>
<ol start="0">
<li><p>Symbol 基础数据类型的特点和应用</p>
<p>应用场景1：使用Symbol来作为对象属性名(key)</p>
<p>Symbol类型的key是不能通过Object.keys()或者for…in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。<br>也正因为这样一个特性，当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外</p>
<p>// 使用Object的API<br>Object.getOwnPropertySymbols(obj) // [Symbol(name)]</p>
<p>// 使用新增的反射API<br>Reflect.ownKeys(obj) </p>
<p>应用场景2：使用Symbol来替代常量,可以避免命名突出的问题，即可以保障常量值的唯一性</p>
<p>const TYPE_AUDIO = Symbol()<br>const TYPE_VIDEO = Symbol()<br>const TYPE_IMAGE = Symbol()</p>
<p>应用场景3：使用Symbol定义类的私有属性/方法<br>我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。<br>因此这对我们进行API的设计时造成了一些困扰。而有了Symbol以及模块化机制，类的私有属性和方法才变成可能</p>
<p>注册和获取全局Symbol<br>let gs1 = Symbol.for(‘global_symbol_1’)  //注册一个全局Symbol<br>let gs2 = Symbol.for(‘global_symbol_1’)  //获取全局Symbol<br>gs1 === gs2  // true</p>
</li>
</ol>
<ol>
<li><p>javascript的typeof返回哪些数据类型.<br>答案：string,boolean,number,undefined,function,object</p>
</li>
<li><p>例举3种强制类型转换和2种隐式类型转换?<br>答案：强制（parseInt,parseFloat,number）<br>隐式（== ===）</p>
</li>
<li><p>split() join() 的区别<br>答案：前者是将字符串切割成数组的形式，后者是将数组转换成字符串</p>
</li>
<li><p>数组方法pop() push() unshift() shift()<br>答案：push()尾部添加 pop()尾部删除<br>unshift()头部添加 shift()头部删除</p>
</li>
<li><p>IE和标准下有哪些兼容性的写法<br>答案：</p>
</li>
</ol>
<p>var ev = ev || window.event<br>document.documentElement.clientWidth || document.body.clientWidth<br>Var target = ev.srcElement||ev.target</p>
<ol start="6">
<li><p>ajax请求的时候get 和post方式的区别<br>答案：<br>一个在url后面 ，一个放在虚拟载体里面<br>get有大小限制(只能提交少量参数)<br>安全问题<br>应用不同 ，请求数据和提交数据</p>
</li>
<li><p>call和apply的区别<br>答案：<br>Object.call(this,obj1,obj2,obj3)<br>Object.apply(this,arguments)</p>
</li>
<li><p>ajax请求时，如何解析json数据<br>答案：使用JSON.parse</p>
</li>
<li><p>事件委托是什么<br>答案: 利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p>
</li>
<li><p>闭包是什么，有什么特性，对页面有什么影响<br>答案：闭包就是能够读取其他函数内部变量的函数,使得函数不被GC回收，如果过多使用闭包，容易导致内存泄露</p>
</li>
<li><p>如何阻止事件冒泡<br>答案：ie:阻止冒泡ev.cancelBubble = true;非IE ev.stopPropagation();</p>
</li>
<li><p>如何阻止默认事件<br>答案：(1)return false；(2) ev.preventDefault();</p>
</li>
<li><p>添加 删除 替换 插入到某个接点的方法<br>答案：</p>
</li>
</ol>
<p>1）创建新节点<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点</p>
<p>2）添加、移除、替换、插入<br>appendChild() //添加<br>removeChild() //移除<br>replaceChild() //替换<br>insertBefore() //插入</p>
<p>3）查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值<br>getElementById() //通过元素Id，唯一性</p>
<ol start="14">
<li><p>解释jsonp的原理，以及为什么不是真正的ajax<br>答案：动态创建script标签，回调函数<br>Ajax是页面无刷新请求数据操作</p>
</li>
<li><p>document load 和document ready的区别<br>答案：document.onload 是在结构和样式,外部js以及图片加载完才执行js<br>document.ready是dom树创建完成就执行的方法，原生种没有这个方法，jquery中有 $().ready(function)</p>
</li>
<li><p>”==”和“===”的不同<br>答案：前者会自动转换类型,再判断是否相等<br>后者不会自动类型转换，直接去比较</p>
</li>
<li><p>函数声明与函数表达式的区别？<br>在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。</p>
</li>
<li><p>对作用域上下文和this的理解，看下列代码：<br>var User = {<br>count: 1,<br>getCount: function() {<br>return this.count;<br>}<br>};<br>console.log(User.getCount()); // what?<br>var func = User.getCount;<br>console.log(func()); // what?<br>问两处console输出什么？为什么？<br>答案:是1和undefined。<br>　　func是在window的上下文中被执行的，所以不会访问到count属性。</p>
</li>
<li>看下面代码，给出输出结果。<br>for(var i = 1; i &lt;= 3; i++){  //建议使用let 可正常输出i的值<br>setTimeout(function(){<br>  console.log(i);<br>},0);<br>};<br>答案：4 4 4。<br>原因：Javascript事件处理器在线程空闲之前不会运行。</li>
<li><p>当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做?<br>box.onlick= function(){}<br>box.addEventListener(“click”,function(){},false);</p>
<button onclick="xxx()"></button>
</li>
<li><p>Javascript的事件流模型都有什么?<br>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播</p>
</li>
</ol>
<p>“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的</p>
<p>“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</p>
<ol start="22">
<li>看下列代码,输出什么?解释原因。<br>var a = null;<br>alert(typeof a);<br>答案：object<br>解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。</li>
<li>判断字符串以字母开头，后面可以是数字，下划线，字母，长度为6-30<br>var reg=/^[a-zA-Z]\w{5,29}$/;</li>
<li>回答以下代码，alert的值分别是多少？<br><script><br> var a = 100;<br> function test(){  <pre><code>alert(a);  
</code></pre> a = 10;  //去掉了var 就变成定义了全局变量了<pre><code>alert(a);  
</code></pre>}<br>test();<br>alert(a);<br></script><br>正确答案是： 100， 10， 10</li>
<li>javaScript的2种变量范围有什么不同？<br>全局变量：当前页面内有效</li>
</ol>
<p>局部变量：函数方法内有效</p>
<ol start="26">
<li>null和undefined的区别？<br>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</li>
</ol>
<p>当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2）调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<ol start="27">
<li>new操作符具体干了什么呢?<br>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
</ol>
<p>2、属性和方法被加入到 this 引用的对象中。</p>
<p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<ol start="28">
<li><p>js延迟加载的方式有哪些？<br>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js</p>
</li>
<li><p>Flash、Ajax各自的优缺点，在使用中如何取舍？<br>Flash ajax对比</p>
</li>
</ol>
<p>(1)Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。</p>
<p>(2)ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</p>
<p>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</p>
<ol start="30">
<li>写一个获取非行间样式的函数<br>function getStyle(obj,attr) {<br>if(obj.currentStyle) {<br>return obj.currentStyle[attr];<br>}else{<br>getComputedStyle(obi,false)[attr]<br>}</li>
</ol>
<p>}</p>
<ol start="31">
<li>希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)<br>var inputs = document.getElementsByTagName(“input”);//获取所有的input标签对象<br>var checkboxArray = [];//初始化空数组，用来存放checkbox对象。<br>for(var i=0;i&lt;inputs.length;i++){<br>var obj = inputs[i];<br>if(obj.type==’checkbox’){<br> checkboxArray.push(obj);<br>}<br>}</li>
<li>写一个function，清除字符串前后的空格。（兼容所有浏览器）<br>String.prototype.trim= function(){</li>
</ol>
<p>return this.replace(/^\s+/,””).replace(/\s+$/,””);</p>
<p>}</p>
<ol start="33">
<li><p>javascript语言特性中，有很多方面和我们接触的其他编程语言不太一样,请举例<br>javascript语言实现继承机制的核心就是 1 (原型)，而不是Java语言那样的类式继承。Javascript解析引擎在读取一个Object的属性的值时，会沿着 2 (原型链)向上寻找，如果最终没有找到，则该属性值为 3 undefined；如果最终找到该属性的值，则返回结果。与这个过程不同的是，当javascript解析引擎执行“给一个Object的某个属性赋值”的时候，如果当前Object存在该属性，则改写该属性的值，如果当前的Object本身并不存在该属性，则赋值该属性的值。</p>
</li>
<li><p>Cookie在客户机上是如何存储的<br>Cookies就是服务器暂存放在你的电脑里的文本文件，好让服务器用来辨认你的计算机。当你在浏览网站的时候，Web服务器会先送一小小资料放在你的计算机上，Cookies 会帮你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookies资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。</p>
</li>
<li><p>如何获取javascript三个数中的最大值和最小值？<br>Math.max(a,b,c);//最大值</p>
</li>
</ol>
<p>Math.min(a,b,c)//最小值</p>
<ol start="36">
<li><p>javascript是面向对象的，怎么体现javascript的继承关系？<br>使用prototype原型来实现。</p>
</li>
<li><p>.form中的input可以设置为readonly和disable，请问2者有什么区别？<br>readonly不可编辑，但可以选择和复制；值可以传递到后台<br>disabled不能编辑，不能复制，不能选择；值不可以传递到后台</p>
</li>
<li><p>列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。<br>主要数据类型：string, boolean, number</p>
</li>
</ol>
<p>复合数据类型：function, object</p>
<p>特殊类型：undefined，null</p>
<ol start="39">
<li>程序中捕获异常的方法？<br>try{</li>
</ol>
<p>}catch(e){</p>
<p>}finally{</p>
<p>}</p>
<ol start="40">
<li>Ajax原理<br>(1)创建对象</li>
</ol>
<p>var xhr = new XMLHttpRequest();</p>
<p>(2)打开请求</p>
<p>xhr.open(‘GET’, ‘example.txt’, true);</p>
<p>(3)发送请求</p>
<p>xhr.send(); 发送请求到服务器</p>
<p>(4)接收响应</p>
<p>xhr.onreadystatechange =function(){}</p>
<p>(1)当readystate值从一个值变为另一个值时，都会触发readystatechange事件。</p>
<p>(2)当readystate==4时，表示已经接收到全部响应数据。</p>
<p>(3)当status ==200时，表示服务器成功返回页面和数据。</p>
<p>(4)如果(2)和(3)内容同时满足，则可以通过xhr.responseText，获得服务器返回的内容。</p>
<ol start="41">
<li>解释什么是Json:<br>(1)JSON 是一种轻量级的数据交换格式。</li>
</ol>
<p>(2)JSON 独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言。</p>
<p>(3)JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null),数组，对象</p>
<ol start="42">
<li><p>js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？<br>alert<br>confirm<br>prompt</p>
</li>
<li><p>以下代码执行结果<br>var uname = ‘jack’<br>function change() {<br>alert(uname) // ?<br>var uname = ‘lily’<br>alert(uname)  //?<br>}<br>change()<br>分别alert出 undefined，lily，（变量声明提升，但变量的初始化、赋值不会提升）</p>
</li>
<li>浏览器的滚动距离：<br>可视区域距离页面顶部的距离</li>
</ol>
<p>scrollTop=document.documentElement.scrollTop||document.body.scrollTop</p>
<ol start="45">
<li>可视区的大小：<br>(1)innerXXX（不兼容ie）</li>
</ol>
<p>window.innerHeight 可视区高度，包含滚动条宽度</p>
<p>window.innerWidth 可视区宽度，包含滚动条宽度</p>
<p>(2)document.documentElement.clientXXX(兼容ie)</p>
<p>document.documentElement.clientWidth可视区宽度，不包含滚动条宽度</p>
<p>document.documentElement.clientHeight可视区高度，不包含滚动条宽度</p>
<ol start="46">
<li>节点的种类有几种，分别是什么？<br>(1)元素节点：nodeType ===1;</li>
</ol>
<p>(2)文本节点：nodeType ===3;</p>
<p>(3)属性节点：nodeType ===2;</p>
<ol start="47">
<li>innerHTML和outerHTML的区别<br>innerHTML(元素内包含的内容）</li>
</ol>
<p>outerHTML(自己以及元素内的内容）</p>
<ol start="48">
<li>offsetWidth offsetHeight和clientWidth clientHeight的区别<br>(1)offsetWidth （content宽度+padding宽度+border宽度）</li>
</ol>
<p>(2)offsetHeight（content高度+padding高度+border高度）</p>
<p>(3)clientWidth（content宽度+padding宽度）</p>
<p>(4)clientHeight（content高度+padding高度）</p>
<ol start="49">
<li>闭包的好处<br>(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)</li>
</ol>
<p>(2)避免全局变量的污染</p>
<p>(3)私有成员的存在</p>
<p>(4)安全性提高</p>
<ol start="50">
<li><p>冒泡排序算法<br>冒泡排序<br>var array = [5, 4, 3, 2, 1];<br>var temp = 0;<br>for (var i = 0; i &lt;array.length; i++){<br>for (var j = 0; j &lt;array.length - i; j++){<br>if (array[j] &gt; array[j + 1]){<br>temp = array[j + 1];<br>array[j + 1] = array[j];<br>array[j] = temp;<br>}<br>}<br>51、js 实现一个函数对javascript中json 对象进行克隆<br>var oldObject =”sdf”;<br>var newObject = JSON.parse(JSON.stringify(oldObject));<br>console.log(newObject);<br>或者<br>var a = ‘dddd’;<br>function cp(a){return JSON.parse(JSON.stringify(a))}<br>console.log(cp(a));<br>52、js 实现 ajax 请求或者submit请求时 锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）<br>function(url, fn) {<br>var obj = new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据<br>obj.open(‘GET’, url, true);<br>obj.onreadystatechange = function() {<br>if(obj.readyState == 4 &amp;&amp; obj.status == 200||obj.status == 304) {</p>
<pre><code>   loading.style.display = &quot;none&quot;

} else {

   alert(&quot;不能点击,哈哈哈!&quot;);

}
</code></pre><p>};<br>obj.send(null);<br>}</p>
</li>
</ol>
<p>53、js 实现一个函数 获得url参数的值<br>function getQueryString(name) {<br>  var reg = new RegExp(“(^|&amp;)” + name + “=([^&amp;]<em>)(&amp;|$)”, “i”);<br>  var r = window.location.search.substr(1).match(reg);<br>  if (r != null) return unescape(r[2]); return null;<br>}<br>54、请用js计算1-10000中出现的0 的次数<br>new Array(10000).fill(‘’).map((_, index) =&gt; index + 1).filter(item =&gt; /0/.test(item)).reduce((count, item) =&gt; { return count + (String(item).match(/0/g) || []).length}, 0)<br>55、写一个function，清除字符串前后的空格。（兼容所有浏览器）<br>function trim(str) {<br>    if (str &amp; typeof str === “string”) {<br>        return str.replace(/(^\s+)|(\s+)$/g,””); //去除前后空白符<br>    }<br>}<br>56、降维数组<br>var arr=[[1,2],[3,4]];<br>function Jw(obj){<br>     return Array.prototype.concat.apply([],obj);<br>}<br>Jw(arr);<br>57、将url的查询参数解析成字典对象<br>···<br>function getQueryObject(url) {<br>url = url == null ? window.location.href : url;<br>var search = url.substring(url.lastIndexOf(“?”) + 1);<br>var obj = {};<br>var reg = /([?&amp;=]+)=([?&amp;=]</em>)/g;<br>search.replace(reg, function (rs, 1,2) {<br>var name = decodeURIComponent(1); var val = decodeURIComponent(2);<br>val = String(val);<br>obj[name] = val;<br>return rs;<br>});<br>return obj;<br>}<br>···</p>
<p>58、判断一个字符串中出现次数最多的字符，统计这个次数<br>···<br>var str = ‘asdfssaaasasasasaa’;<br>var json = {};</p>
<p>for (var i = 0; i &lt; str.length; i++) {<br>if(!json[str.charAt(i)]){<br>json[str.charAt(i)] = 1;<br>}else{<br>json[str.charAt(i)]++;<br>}<br>};<br>var iMax = 0;<br>var iIndex = ‘’;<br>for(var i in json){<br>if(json[i]&gt;iMax){<br>iMax = json[i];<br>iIndex = i;<br>}<br>}<br>alert(‘出现次数最多的是:’+iIndex+’出现’+iMax+’次’);<br>···</p>
<p>59、编写一个方法 求一个字符串的字节长度;<br>···<br>//假设一个中文占两个字节<br>var str = ‘22两是’;</p>
<p>alert(getStrlen(str))</p>
<p>function getStrlen(str){<br>var json = {len:0};<br>var re = /[\u4e00-\u9fa5]/;<br>for (var i = 0; i &lt; str.length; i++) {<br>if(re.test(str.charAt(i))){<br>json[‘len’]++;<br>}<br>};<br>return json[‘len’]+str.length;<br>}<br>···</p>
<p>60、编写一个方法 去掉一个数组的重复元素<br>···<br>var arr = [1,2,3,1,43,12,12,1];<br>var json = {};<br>var arr2 = [];<br>for (var i = 0; i &lt; arr.length; i++) {<br>if(!json[arr[i]]){<br>json[arr[i]] = true;<br>}else{<br>json[arr[i]] = false;<br>}</p>
<pre><code>if(json[arr[i]]){
        arr2.push(arr[i]);
}
</code></pre><p>};</p>
<p>for (var i = 0; i &lt; arr.length; i++) {<br>if(!aa(arr[i], arr2)){<br>arr2.push(arr[i])<br>}<br>};<br>function aa(obj, arr){<br>for (var i = 0; i &lt; arr.length; i++) {<br>if(arr[i] == obj) return true;<br>else return false;<br>};<br>}<br>alert(arr2)<br>···</p>
<p>61、写出3个使用this的典型应用<br>事件： 如onclick this-&gt;发生事件的对象<br>构造函数 this-&gt;new 出来的object<br>call/apply 改变this</p>
<p>62、如何深度克隆<br>···<br>var arr = [1,2,43];<br>var json = {a:6,b:4,c:[1,2,3]};<br>var str = ‘sdfsdf’;</p>
<p>var json2 = clone(json);</p>
<p>alert(json[‘c’])<br>function clone(obj){<br>var oNew = new obj.constructor(obj.valueOf());<br>if(obj.constructor == Object){<br>for(var i in obj){<br>oNew[i] = obj[i];<br>if(typeof(oNew[i]) == ‘object’){<br>clone(oNew[i]);<br>}<br>}<br>}<br>return oNew;<br>}<br>···</p>
<p>63、JavaScript中如何检测一个变量是一个String类型？请写出函数实现<br>···<br>typeof(obj) == ‘string’<br>obj.constructor == String;<br>···</p>
<p>64、网页中实现一个计算当年还剩多少时间的倒数计时程序，要求网页上实时动态显示“××年还剩××天××时××分××秒”<br>···<br>var oDate = new Date();<br>var oYear = oDate.getFullYear();</p>
<p>var oNewDate = new Date();<br>oNewDate.setFullYear(oYear, 11, 31, 23, 59, 59);<br>var iTime = oNewDate.getTime()-oDate.getTime();</p>
<p>var iS = iTime/1000;<br>var iM = oNewDate.getMonth()-oDate.getMonth();<br>var iDate =iS<br>···</p>
<p>65、请解释一下什么是语义化的HTML。<br>内容使用特定标签，通过标签就能大概了解整体页面的布局分布</p>
<p>66、为什么利用多个域名来存储网站资源会更有效？<br>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站</p>
<p>67、请说出三种减低页面加载时间的方法<br>1、压缩css、js文件<br>2、合并js、css文件，减少http请求<br>3、外部js、css文件放在最底下<br>4、减少dom操作，尽可能用变量替代不必要的dom操作</p>
<p>68、什么是FOUC？你如何来避免FOUC？<br>由于css引入使用了@import 或者存在多个style标签以及css文件在页面底部引入使得css文件加载在html之后导致页面闪烁、花屏<br>用link加载css文件，放在head标签里面</p>
<p>69、文档类型的作用是什么？你知道多少种文档类型？<br>影响浏览器对html代码的编译渲染<br>html2.0<br>xHtml<br>html5</p>
<p>70、浏览器标准模式和怪异模式之间的区别是什么？<br>盒模型解释不同</p>
<p>71、闭包<br>子函数能被外部调用到，则该作用连上的所有变量都会被保存下来。</p>
<p>72、请解释什么是Javascript的模块模式，并举出实用实例。<br>js模块化mvc（数据层、表现层、控制层）<br>seajs<br>命名空间</p>
<p>73、你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？<br>对内：模块模式<br>对外：继承</p>
<p>74、你如何优化自己的代码？<br>代码重用<br>避免全局变量（命名空间，封闭空间，模块化mvc..）<br>拆分函数避免函数过于臃肿<br>注释</p>
<p>75、你能解释一下JavaScript中的继承是如何工作的吗？<br>子构造函数中执行父构造函数，并用call\apply改变this<br>克隆父构造函数原型上的方法</p>
<p>76、请尽可能详尽的解释AJAX的工作原理。<br>创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）<br>判断数据传输方式(GET/POST)<br>打开链接 open()<br>发送 send()<br>当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数</p>
<p>77、最简单的一道题<br>···<br>var a = 2, b = 3;<br>var c = a+++b; // c = 5<br>···</p>
<p>78、var和function的预解析问题,以及变量和function的先后顺序的问题<br>···<br>// 以下代码执行输出结果是什么<br>function b () {<br>console.log(a);<br>var a = 10;<br>function a() {};<br>a = 100;<br>console.log(a);<br>}<br>b();</p>
<p>function c () {<br>    console.log(a);<br>    function a() {};<br>    var a = 10;<br>    a = 100;<br>    console.log(a);<br>}<br>c();</p>
<p>(function d (num) {<br>    console.log(num);<br>    var num = 10;<br>}(100))</p>
<p>(function e (num) {<br>    console.log(num);<br>    var num = 10;<br>    function num () {};<br>}(100))</p>
<p>(function f (num) {<br>    function num () {};<br>    console.log(num);<br>    var num =10<br>    console.log(num);<br>}(100))</p>
<p>//仍然是预解析(在与解析过程中还要考虑一下当前变量的作用于)<br>function m () {<br>    console.log(a1); // underfined<br>    console.log(a2); // underfined<br>    console.log(b1); // underfined<br>    console.log(b2); // underfined<br>    if(false) {<br>        function b1 (){};<br>        var a1 = 10;<br>    }<br>    if(true) {<br>        function b2 (){};<br>        var a2 = 10;<br>    }<br>    console.log(a1); // underfined<br>    console.log(a2); // 10<br>    console.log(b1); // underfined<br>    console.log(b2); // function<br>}<br>m();</p>
<p>function n() {<br>    if(2&gt;1) {<br>        arr = 10;<br>        brr = 10;<br>        let arr;<br>        var brr;<br>        console.log(arr);<br>        console.log(brr);<br>    }<br>}<br>n(); // ReferenceError<br>···</p>
<p>79、dom事件委托什么原理，有什么优缺点<br>事件委托原理:事件冒泡机制<br>优点<br>1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。<br>2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</p>
<p>缺点<br>事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</p>
<p>80、http的cache机制，以及200状态下怎么实现 from cache（表示接触最多的就是304的from cache）（用于优化，没有接触过，需要理解）<br>含义<br>定义：浏览器缓存（Browser Caching）是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p>
<p>作用<br>cache的作用：<br>1、减少延迟，让你的网站更快，提高用户体验。<br>2、避免网络拥塞，减少请求量，减少输出带宽。</p>
<p>实现手段<br>Cache-Control中的max-age是实现内容cache的主要手段，共有3种常用策略：max-age和Last-Modified（If-Modified-Since）的组合、仅max-age、max-age和ETag的组合。</p>
<p>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。<br>对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<p>81、一个原型链继承的问题<br>    // 有一个构造函数A，写一个函数B，继承A<br>    function A (num) {<br>        this.titileName = num;<br>    }<br>    A.prototype = {<br>        fn1: function () {},<br>        fn2: function () {}<br>    }<br>这个问题的关注点是B继承的A的静态属性，同时B的原型链中不存在A实例的titleName属性</p>
<p>82、什么是虚拟dom<br>React为啥这么大？因为它实现了一个虚拟DOM（Virtual DOM）。虚拟DOM是干什么的？这就要从浏览器本身讲起</p>
<p>如我们所知，在浏览器渲染网页的过程中，加载到HTML文档后，会将文档解析并构建DOM树，然后将其与解析CSS生成的CSSOM树一起结合产生爱的结晶——RenderObject树，然后将RenderObject树渲染成页面（当然中间可能会有一些优化，比如RenderLayer树）。这些过程都存在与渲染引擎之中，渲染引擎在浏览器中是于JavaScript引擎（JavaScriptCore也好V8也好）分离开的，但为了方便JS操作DOM结构，渲染引擎会暴露一些接口供JavaScript调用。由于这两块相互分离，通信是需要付出代价的，因此JavaScript调用DOM提供的接口性能不咋地。各种性能优化的最佳实践也都在尽可能的减少DOM操作次数。</p>
<p>而虚拟DOM干了什么？它直接用JavaScript实现了DOM树（大致上）。组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React又通过在这个虚拟DOM上实现了一个 diff 算法找出最小变更，再把这些变更写入实际的DOM中。这个虚拟DOM以JS结构的形式存在，计算性能会比较好，而且由于减少了实际DOM操作次数，性能会有较大提升</p>
<p>83、js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型<br>1.基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String<br>2.引用数据类型（对象）：Object （Array，Date，RegExp，Function）<br>ES6基本数据类型多了个symbol 据说这道题刷了百分之二十的人 感谢Abbyshen提出</p>
<p>function gettype(nm){<br>    return Object.prototype.toString.call(nm);<br>}<br>84、 dom选择器优先级是什么，以及权重值计算（一道老问题了）<br>1.行内样式 1000<br>2.id 0100<br>3.类选择器、伪类选择器、属性选择器[type=”text”] 0010<br>4.标签选择器、伪元素选择器(::first-line) 0001<br>5.通配符*、子选择器、相邻选择器 0000</p>
<p>85、vue双向数据绑定的原理是什么<br>首先传输对象的双向数据绑定 Object.defineProperty(target, key, decription),在decription中设置get和set属性（此时应注意description中get和set不能与描述属性共存）<br>数组的实现与对象不同。<br>同时运用观察者模式实现wather，用户数据和view视图的更新</p>
<p>86、 react和vue比较来说有什么区别<br>1 component层面，web component和virtual dom<br>2 数据绑定（vue双向，react的单向）等好多<br>3 计算属性 vue 有，提供方便；而 react 不行<br>4 vue 可以 watch 一个数据项；而 react 不行<br>5 vue 由于提供的 direct 特别是预置的 directive 因为场景场景开发更容易；react 没有<br>6 生命周期函数名太长 directive</p>
<p>87、git使用过程中，如果你在开发着业务，突然另一个分支有一个bug要改，你怎么办<br>git stash       //将本次修改存到暂存区（紧急切换分支时）<br>git stash pop   //将所有暂存区的内容取出来</p>
<p>88、 网页布局有哪几种，有什么区别<br>静态、自适应、流式、响应式四种网页布局<br>静态布局：意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；<br>自适应布局：就是说你看到的页面，里面元素的位置会变化而大小不会变化；<br>流式布局：你看到的页面，元素的大小会变化而位置不会变化——这就导致如果屏幕太大或者太小都会导致元素无法正常显示。<br>自适应布局：每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p>
<p>89、执行下面代码<br>var a = {};<br>var b = {key: ‘b’};<br>var c = {key: ‘c’};<br>var d = [3,5,6];<br>a[b] = 123;<br>a[c] = 345;<br>a[d] = 333;<br>console.log(a[b]);  // 345<br>console.log(a[c]);  // 345<br>console.log(a[d]);  // 333<br>90、<br>    var R = (function() {<br>        var u = {a:1,b:2};<br>        var r = {<br>            fn: function(k) {<br>                return u[k];<br>            }<br>        }<br>        return r;<br>    }());<br>    R.fn(‘a’);  // 1<br>上述代码中如何获取匿名函数中的u</p>
<p>91、不适用循环语句（包括map、forEach方法）实现一个100长度的数组，索引值和值相同的数组[0,1,2,3,4,5……..99]<br>var arr = new Array(100);<br>//方法1<br>[…arr.keys()];<br>//方法二<br>Array.from(arr.keys());</p>
<p>//方法三<br>Array.from({length: 100});</p>
<p>// 方法四 借助string<br>var arr1 = new Array(101);<br>var str = arr1.join(‘1,’);<br>str = str.replace(/(1\,)/g, function ($0, $1, index) {<br>    var start = ‘’ + Math.ceil(index/2);<br>    if(index &lt; str.length - 2) {<br>        start += ‘,’<br>    }<br>    return start;<br>});<br>return str.split(‘,’);</p>
<p>// 方法五（函数式，参考网络）<br>function reduce(arr, val) {<br>    if(Object.prototype.toString.apply(val)){<br>        return;<br>    }<br>    if(val &gt;= 100) {<br>        return arr;<br>    }<br>    arr.push(val);<br>    return reduce(arr, val+1);<br>}<br>var res = reduce([], 0)<br>92、下面语句执行结果输出<br>var a = function (val, index) {<br>    console.log(index);<br>    return {<br>        fn: function (name) {<br>            return a(name, val);<br>        }<br>    }<br>}</p>
<p>var b = a(0); // underfined<br>b.fn(1); // 0<br>b.fn(2); // 0<br>b.fn(3); // 0<br>93、科普<br>dom节点的根节点是不是body<br>回答： 不是，dom节点的根节点是html(包含head和body，head中分为meta、title等。body又分为一组)<br>2）dom元素都会有offsetParent吗<br>回答： offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素(在标准兼容模式下为html元素；在怪异呈现模式下为body元素)的引用。 当容器元素的style.display 被设置为 “none”时（译注：IE和Opera除外），offsetParent属性 返回 null。</p>
<p>[1,3,5]转译成字符串是什么<br>回答： ‘1,3,5’<br>调用toString方法，生成该字符串<br>4）li标签的祖级元素可以为li，父级元素也可以为例<br>回答： 错误</p>
<p>94、 jsonp原理，jquery是怎么实现的，这样实现有什么好处和坏处<br>原理<br>在同源策略下;在某个服务器下的页面是无法获取到该服务器以外的数据的;Jquery中ajax 的核心是通过 XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加 <script>标签来调用服务器提供的 js脚本<br>当我们正常地请求一个JSON数据的时候，服务端返回的是一串 JSON类型的数据，而我们使用 JSONP模式来请求数据的时候服务端返回的是一段可执行的 JavaScript代码。因为jsonp 跨域的原理就是用的动态加载 script的src ，所以我们只能把参数通过 url的方式传递, 所以jsonp的 type类型只能是get ！</p>
<p>$.ajax({<br>    url: ‘<a href="http://192.168.1.114/yii/demos/test.php&#39;">http://192.168.1.114/yii/demos/test.php&#39;</a>, //不同的域<br>    type: ‘GET’, // jsonp模式只有GET 是合法的<br>    data: {<br>        ‘action’: ‘aaron’<br>    },<br>    dataType: ‘jsonp’, // 数据类型<br>    jsonp: ‘backfunc’, // 指定回调函数名，与服务器端接收的一致，并回传回来<br>})<br>其实jquery 内部会转化成<br><a href="http://192.168.1.114/yii/demos/test.php?backfunc=jQuery2030038573939353227615_1402643146875&amp;action=aaron">http://192.168.1.114/yii/demos/test.php?backfunc=jQuery2030038573939353227615_1402643146875&amp;action=aaron</a><br>然后动态加载</p>
<p>&lt;script type=”text/javascript”src=”<a href="http://192.168.1.114/yii/demos/test.php?backfunc=&gt;">http://192.168.1.114/yii/demos/test.php?backfunc=&gt;</a><br>然后后端就会执行backfunc(传递参数 )，把数据通过实参的形式发送出去。</p>
<p>在jquery 源码中， jsonp的实现方式是动态添加<script>标签来调用服务器提供的 js脚本。jquery 会在window对象中加载一个全局的函数，当 <script>代码插入时函数执行，执行完毕后就 <script>会被移除。同时jquery还对非跨域的请求进行了优化，如果这个请求是在同一个域名下那么他就会像正常的 Ajax请求一样工作。</p>
<p>95、 http协议属于七层协议中的哪一层，下一层是什么<br>七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>tcp属于传输层；http属于应用层。<br>表现层</p>
<p>96、 js垃圾回收机制知道哪些，v8引擎使用的哪一种<br>js的两种回收机制<br>1 标记清除（mark and sweep）<br>2 引用计数（reference counting）</p>
<p>javascript与V8引擎<br>垃圾回收机制的好处和坏处</p>
<p>好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。</p>
<p>坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。</p>
<p>V8 自动垃圾回收算法<br><a href="https://segmentfault.com/a/11..">https://segmentfault.com/a/11..</a>.</p>
<p>97、 作用域什么时候生成的？<br>页面加载–&gt;创建window全局对象，并生成全局作用域–&gt;然后生成执行上下文，预解析变量(变量提升)，生成全局变量对象；<br>$scope</p>
<p>98、 websocket长连接原理是什么<br>含义<br>Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。</p>
<p>原理<br>类似长轮循长连接 ; 发送一次请求 ; 源源不断的得到信息</p>
<ol start="28">
<li>http缓存知道哪些<br><a href="http://blog.csdn.net/yzf91321..">http://blog.csdn.net/yzf91321..</a>.</li>
</ol>
<p>99、 讲一下事件循环机制<br>执行上下文(Execution context)<br>函数调用栈(call stack)<br>队列数据结构(queue)<br>Promise</p>
<p><a href="https://zhuanlan.zhihu.com/p/..">https://zhuanlan.zhihu.com/p/..</a>.</p>
<p>100、 理解web安全吗？都有哪几种，介绍以及如何预防<br>1.XSS，也就是跨站脚本注入</p>
<p>攻击方法：<br>1. 手动攻击:<br>编写注入脚本，比如”/&gt;<script>alert(document.cookie());</script>&lt;!–等，<br>手动测试目标网站上有的input, textarea等所有可能输入文本信息的区域<br>2. 自动攻击<br>利用工具扫描目标网站所有的网页并自动测试写好的注入脚本，比如：Burpsuite等<br>防御方法：<br>1. 将cookie等敏感信息设置为httponly，禁止Javascript通过document.cookie获得<br>2. 对所有的输入做严格的校验尤其是在服务器端，过滤掉任何不合法的输入，比如手机号必须是数字，通常可以采用正则表达式<br>3. 净化和过滤掉不必要的html标签，比如：iframe, alt,script 等<br>4. 净化和过滤掉不必要的Javascript的事件标签，比如：onclick, onfocus等<br>5. 转义单引号，双引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符<br>6. 设置浏览器的安全设置来防范典型的XSS注入</p>
<p>2.SQL注入</p>
<p>攻击方法：<br>编写恶意字符串，比如‘ or  1=1–等，<br>手动测试目标网站上所有涉及数据库操作的地方<br>防御方法：<br>1. 禁止目标网站利用动态拼接字符串的方式访问数据库<br>2. 减少不必要的数据库抛出的错误信息<br>3. 对数据库的操作赋予严格的权限控制<br>4. 净化和过滤掉不必要的SQL保留字，比如：where, or, exec 等<br>5. 转义单引号，上引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符</p>
<p>3.CSRF，也就是跨站请求伪造</p>
<p>就是攻击者冒用用户的名义，向目标站点发送请求<br>防范方法：<br>1. 在客户端进行cookie的hashing，并在服务端进行hash认证<br>2. 提交请求是需要填写验证码<br>3. 使用One-Time Tokens为不同的表单创建不同的伪随机值  </p>
<p>101、 sessionStorage和localstorage能跨域拿到吗？比如我在<a href="http://www.baidu.com设置的值能在m.baidu.com能拿到吗？为什么" target="_blank" rel="noopener">www.baidu.com设置的值能在m.baidu.com能拿到吗？为什么</a><br>localStorage会跟cookie一样受到跨域的限制，会被document.domain影响</p>
<p>102、 localstorage不能手动删除的时候，什么时候过期<br>除非被清除，否则永久保存 clear()可清楚<br>sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除</p>
<p>103、cookie可以设置什么域？可以设置.com吗<br>可以通过设置domin来实现</p>
<p>104、登录状态的保存你认为可以保存在sessionstorage或者localstorage或者cookie或者你知道的哪种方式，存在了哪里？？为什么保存在那里<br>105、 flux -&gt; redux -&gt; mobx 变化的本质是什么<br>存储结构 将对象加工可观察 函数式 vs 面向对象<br><a href="https://zhuanlan.zhihu.com/p/.." target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/..</a>.</p>
<p>106、 按需加载路由怎么加载对应的chunk文件的？换句话说浏览器怎么知道什么时候加载这个chunk，以及webpack是怎么识别那个多个经过hash过的chunk文件<br>107、get和post有什么区别？get可以通过body传递数据吗<br>把数据放到 body 里面，必须用 POST 方式取，这是 HTTP 协议限制的。</p>
<p>108、右边宽度固定，左边自适应<br>第一种：</p>
<p><style><br>body{<br>    display: flex;<br>}<br>.left{<br>    background-color: rebeccapurple;<br>    height: 200px;<br>    flex: 1;<br>}<br>.right{<br>    background-color: red;<br>    height: 200px;<br>    width: 100px;<br>}<br></style></p>
<p><body><br>    <div class="left"></div><br>    <div class="right"></div><br></body><br>第二种</p>
<p><style><br>    div {<br>        height: 200px;<br>    }<br>    .left {<br>        float: right;<br>        width: 200px;<br>        background-color: rebeccapurple;<br>    }<br>    .right {<br>        margin-right: 200px;<br>        background-color: red;<br>    }<br></style></p>
<p><body><br>    <div class="left"></div><br>    <div class="right"></div><br></body><br>109、水平垂直居中<br>第一种</p>
<p>#container{<br>    position:relative;<br>}</p>
<p>#center{<br>    width:100px;<br>    height:100px;<br>    position:absolute;<br>    top:50%;<br>    left:50%;<br>    transform: translate(-50%,-50%);<br>}<br>第二种</p>
<p>#container{<br>    position:relative;<br>}</p>
<p>#center{<br>    width:100px;<br>    height:100px;<br>    position:absolute;<br>    top:50%;<br>    left:50%;<br>    margin:-50px 0 0 -50px;<br>}<br>第三种</p>
<p>#container{<br>    position:relative;<br>}</p>
<p>#center{<br>    position:absolute;<br>    margin:auto;<br>    top:0;<br>    bottom:0;<br>    left:0;<br>    right:0;<br>}<br>第四种 flex</p>
<p>#container{<br>    display:flex;<br>    justify-content:center;<br>    align-items: center;<br>}<br>109、.四种定位的区别<br>static 是默认值<br>relative 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中<br>absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。<br>fixed 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。</p>
<p>110、封装一个函数，参数是定时器的时间，.then执行回调函数。<br>function sleep (time) {<br>  return new Promise((resolve) =&gt; setTimeout(resolve, time));<br>}<br>111、一行代码实现数组去重？<br>[…new Set([1,2,3,1,’a’,1,’a’])]<br>112、使用addEventListener点击li弹出内容，并且动态添加li之后有效</p>
<p><ul><br>    <li>1</li><br>    <li>2</li><br>    <li>3</li><br>    <li>4</li><br></ul><br>var ulNode = document.getElementById(“ul”);<br>    ulNode.addEventListener(‘click’, function (e) {<br>        if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == “LI”) {<br>            alert(e.target.innerHTML);<br>        }<br>    }, false);<br>113、怎么判断两个对象相等<br>JSON.stringify(obj)==JSON.stringify(obj);//true<br>114、Vue router 除了 router-link 怎么实现跳转?<br>router.go(1)<br>router.push(‘/‘)<br>115、Vue router 跳转和 location.href 有什么区别？<br>router 是 hash 改变<br>location.href 是页面跳转，刷新页面</p>
<p>116、重排和重绘<br>部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。<br>由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。</p>
<p>117、什么情况会触发重排和重绘<br>添加、删除、更新 DOM 节点<br>通过 display: none 隐藏一个 DOM 节点-触发重排和重绘<br>通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化<br>移动或者给页面中的 DOM 节点添加动画<br>添加一个样式表，调整样式属性<br>用户行为，例如调整窗口大小，改变字号，或者滚动。</p>
<p>118、js bind 实现机制？手写一个 bind 方法？<br>function bind(fn, context){<br>  return function (){<br>     return fn.apply(context, arguments);<br>  }<br>}<br>// 柯理化函数思想   感谢pursuitTom的提出<br>Function.prototype.bind = function (context) {<br>    var args = Array.prototype.slice.call(arguments, 1);<br>    var _this = this;<br>    return function () {<br>        var thisArgs = [].slice.call(arguments);<br>        return _this.apply(context, args.concat(thisArgs))<br>    };<br>}<br>// ES6写法 感谢waterc的提出<br>Function.prototype.bind = function(context, …res) {<br>    let self = this<br>    return function(…arg) {<br>        return self.apply(context, […res,…arg])<br>    }<br>}<br>119、多个函数<br>var a = (function(){return ‘1’;}, function(){return 1;})();<br>console.log(typeof a); //number<br>120、proto、prototype、Object.getPrototypeOf()<br><strong>proto</strong>是指内部原型，和Object.getPrototypeOf()结果等价<br>function f(){}<br>f.<strong>proto</strong> === Object.getPrototypeOf(f); //true<br>f.prototype === Object.getPrototypeOf(f); //false<br>121、浏览记录前后跳转（尚未试验）<br><a href="javascript:history.go(-1)" target="_blank" rel="noopener">backward</a><br><a href="javascript:history.go(1)" target="_blank" rel="noopener">forward</a><br>122、setTimeout 和 setInterval 细谈<br>常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。<br>后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。<br>如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval</p>
<p>var time = 400, times = 0, max = 10;<br>function func(){<br>  times++;<br>  if(times &lt; max){<br>    //code here<br>    setTimeout(func, time);<br>  } else {<br>    console.log(“finished”);<br>  }<br>}<br>setTimeout(func, time);<br>123、判断多图片加载完毕<br>注：用jQueryObject.ready()只能判断dom结构加载完毕<br>好像描述的不是很清楚，这里写一下代码。<br>方法1：</p>
<p>var counter = 0;<br>var queryInterval = 30; //ms<br>var pics = document.getElementsByClassName(“pics”);</p>
<p>function singleQuery(i){<br>  if(pics[i].complete){<br>    counter++;<br>    console.log(i + “ is loaded”);<br>  } else {<br>    setTimeout(singleQuery, queryInterval, i);<br>  }<br>}</p>
<p>function allQuery(callback){<br>  if(counter &lt; pics.length){<br>    console.log(“current number of loaded pics: “ + counter);<br>    setTimeout(allQuery, queryInterval, callback);<br>  } else {<br>    console.log(“All pics are loaded.”);<br>    callback();<br>  }<br>}</p>
<p>for(var i = 0; i &lt; pics.length; i++){<br>  setTimeout(singleQuery, queryInterval, i);<br>}</p>
<p>setTimeout(allQuery, queryInterval, callback);</p>
<p>主要也是采用setTimeout模拟轮询，判断方式是img标签dom的complete属性（布尔值），缺点是定时器太多。</p>
<p>方法2：</p>
<p>var counter = 0, queryInterval = 50;<br>var pics = document.getElementsByClassName(“pics”);<br>for(var i = 0; i &lt; pics.length; i++){<br>  pics[i].onload = function(){<br>    counter++;<br>    console.log(this.id + “ is loaded”);<br>  }<br>}</p>
<p>function queryPictures(callback){<br>  if(counter &lt; pics.length){<br>    console.log(“current number of loaded pics: “ + counter);<br>    setTimeout(queryPictures, queryInterval, callback);<br>  } else {<br>    console.log(“All pics are loaded”);<br>    callback();<br>  }<br>}</p>
<p>setTimeout(queryPictures, queryInterval, callback);<br>利用onload绑定图片加载成功后的回调，通过计数器判断是否加载完毕。</p>
<p>124、CSS margin重叠问题<br>块元素在垂直方向上的margin是很奇怪的，会有重叠现象。<br>如果display都是block，有三种情况：<br>外间距均为正数，竖直方向上会选择最大的外边距作为间隔<br>一正一负，间距 = 正 - |负|<br>两个负，间距 = 0 - 绝对值最大的那个<br>设置display: inline-block的盒子不会有margin重叠，position: absolute的也不会出现。</p>
<p>125、CSS选择器优先级 &amp;&amp; CSS选择器效率<br>ID &gt; 类 &gt; 标签 &gt; 相邻 &gt; 子选择器 &gt; 后代选择器 &gt; * &gt; 属性 &gt; 伪类</p>
<p>object.propertyIsEnumerable(xxx)<br>判断对象中是否有xxx属性，并且能通过for in枚举，如Array对象的length是不可枚举的</p>
<p>126、判断数组<br>function isArray(arr){<br>    return Object.prototype.toString.call(arr) === ‘[Object Array]’;<br>}</p>
<p>127、git fetch &amp;&amp; git pull<br>git pull自动完成了fetch最新远程版本，并且和本地进行merge<br>git fetch获得远程分支，要继续手动merge合并</p>
<p>128、WebSocket<br>HTML5带来的新协议，通过类似HTTP的请求建立连接。主要目的是可以获取服务端的推送。<br>原来的方式可能是使用long poll（即不中断连接一直等待数据），或者是ajax轮询的方式（每隔一段时间发送请求，建立连接，询问是否有新的数据）。这两种方式的缺点在于long poll的阻塞，以及ajax轮询的冗余连接。<br>WebSocket的设计思想有点类似于回调，在发送请求升级服务端的协议并收到确认信息后，服务端一有新的信息/数据就会主动推送给客户端，至于要一次HTTP握手便可以建立持久连接</p>
<p>129、跨域相关<br>只要协议、域名、端口有不同，则视为不同的域。（域名和域名对应的IP也是跨域）</p>
<p>1.CORS: Cross-Origin Resource Sharing<br>基于服务器支持的跨域，服务器设置Access-Control-Allow-Origin响应头，浏览器可允许跨域</p>
<p>2.设置domain<br>能从子域设到主域，如a.b.c.com—&gt;b.c.com—&gt;c.com<br>具体情况：在页面中用iframe打开了另一个页面（前提：两个页面主域是相同的）<br>利用frameElement.contentWindow.document.domain设置frame子页面的主域，document.domain设置主页面的主域，之后就能互相获取dom中的数据。<br>缺点是只能用于不同子域间的交互。</p>
<p>3.例如拥有src属性的img标签，每次改变src属性，都会发起http请求。<br>var img = new Image();<br>img.onload = function(){<br>  //code here<br>};<br>img.onerror = function(){<br>  //code here<br>};<br>img.src=”<a href="http://server.com/data?query=3&quot;" target="_blank" rel="noopener">http://server.com/data?query=3&quot;</a>;<br>缺点是只能使用GET请求，不能获取数据，一般用于提交统计信息什么的。<br>script、link、iframe只有在添加到DOM中才会发起请求</p>
<p>4.HTML5 postMessage<br>支持IE8+和主流浏览器，写法也简单..</p>
<p>//source: <a href="http://test.org:4000" target="_blank" rel="noopener">http://test.org:4000</a><br>//get the window object of target origin<br>var win = window.open(“<a href="http://target.com&quot;)" target="_blank" rel="noopener">http://target.com&quot;)</a>;<br>//or this, when a frame is used<br>var win = document.getElementById(“targetId”).contentWindow;<br>win.postMessage(“data here”, “<a href="http://target.com/rest&quot;)" target="_blank" rel="noopener">http://target.com/rest&quot;)</a>;</p>
<p>//target: <a href="http://target.com/tiny" target="_blank" rel="noopener">http://target.com/tiny</a><br>function handleMessage(event){<br>  if(event.orgin!=”<a href="http://test.org:4000&quot;" target="_blank" rel="noopener">http://test.org:4000&quot;</a>)<br>    return;<br>  var data = event.data;<br>  //code here</p>
<p>  //event.source is window.opener<br>  event.source.postMessage(“response data here”, event.origin);<br>}<br>window.addEventListener(“message”, handleMessage, false);<br>5.window.name<br>即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具。<br>但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)：</p>
<ol start="6">
<li>jsonp<br>目前主流跨域方法<br>调用其他域的脚本获取数据，前提是另一个域能知道回调函数名，这个可以通过请求发送给目标域。<br>直接写jQuery封的jsonp</li>
</ol>
<p>$.getJSON(“<a href="http://target.com/data?callback=callbackFunctionName&quot;" target="_blank" rel="noopener">http://target.com/data?callback=callbackFunctionName&quot;</a>, function(data){});<br>$.getJSON会把获取的responseText转为json，如果url中有callback参数，数据会以script标签形式获取。</p>
<p>130、闭包相关<br>什么是闭包<br>闭包是指有权访问另一个函数作用域中变量的函数</p>
<p>怎么创建闭包<br>在函数内部嵌套使用函数</p>
<p>function fn() {<br>           for (var i = 0; i &lt; 2; i++) {<br>               (function () {<br>                   var variate = i;<br>                   setTimeout(function () {<br>                       console.log(“setTimeout执行后:”+variate);<br>                   }, 1000);<br>               })();//闭包,立即执行函数,匿名函数</p>
<pre><code>    }
   console.log(i);//2
   console.log(variate);//variate is not defined
}
fn();
</code></pre><p>为什么用闭包<br>因为在闭包内部保持了对外部活动对象的访问,但外部的变量却无法直接访问内部,避免了全局污染;<br>可以当做私有成员,弥补了因js语法带来的面向对象编程的不足;<br>可以长久的在内存中保存一个自己想要保存的变量.<br>闭包的缺点<br>可能导致内存占用过多,因为闭包携带了自身的函数作用域<br>闭包只能取得外部包含函数中得最后一个值<br>详见<a href="https://segmentfault.com/a/11.." target="_blank" rel="noopener">https://segmentfault.com/a/11..</a>.</p>
<p>131、a:active 移动端实现<br>有时候一些按钮的简单点击交互可以通过css伪类来实现；必须点击了更改颜色；松开恢复；IOS手机会出现伪类无效的情况；iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。</p>
<p>document.body.addEventListener(‘touchstart’, function () { //…空函数即可});<br>132、ios滑动卡顿<br>-webkit-overflow-scrolling:touch 可能会在IOS系统低的情况出现滚动条；尝试溢出解决</p>
<p>133、forEach和map的区别<br>相同点</p>
<p>都是循环遍历数组中的每一项<br>forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）<br>匿名函数中的this都是指向window<br>只能遍历数组<br>都有兼容问题<br>不同点</p>
<p>map速度比foreach快<br>map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，<br>map因为返回数组所以可以链式操作，foreach不能</p>
<p>134、浅拷贝和深拷贝<br>jQuery.extend第一个参数可以是布尔值，用来设置是否深度拷贝的</p>
<p>jQuery.extend(true, { a : { a : “a” } }, { a : { b : “b” } } );<br>jQuery.extend( { a : { a : “a” } }, { a : { b : “b” } } );<br>最简单的深拷贝</p>
<p>aa = JSON.parse( JSON.stringify(a) )<br>浅复制—&gt;就是将一个对象的内存地址的“”编号“”复制给另一个对象。深复制—&gt;实现原理，先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的(注意可枚举的对象)属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到子子…..属性为基本数据类型。总结，深复制理解两点，1,新开辟内存地址，2,递归来刨根复制。</p>
<p>136、js加载位置区别优缺点<br>html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到<script>脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。<br>所以，大部分网上讨论是将script脚本放在<body>之后，那样dom的生成就不会因为长时间执行script脚本而延迟阻塞，加快了页面的加载速度。</p>
<p>但又不能将所有的script放在body之后，因为有一些页面的效果的实现，是需要预先动态的加载一些js脚本。所以这些脚本应该放在<body>之前。</p>
<p>其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效</p>
<p>script放置位置的原则“页面效果实现类的js应该放在body之前，动作，交互，事件驱动，需要访问dom属性的js都可以放在body之后</p>
</script></p></div><div class="tags"><a href="/tags/JavaScript-面试题/">JavaScript 面试题</a></div><div class="post-nav"><a class="pre" href="/2019/07/25/js-basic-questions/">JavaScript 基础面试题</a><a class="next" href="/2019/07/25/nodejs-eventloop-macrotask-microtask/">macrotask and microtask in event loop of node.js</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'a3cb922b42c58d027028',
  clientSecret: 'c2f29aa3937d056e771535723d1d6b099e109d9c',
  repo: 'bin5i.github.io',
  owner: 'bin5i',
  admin: ['bin5i'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://bin.5i.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术分享/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活随笔/">生活随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/freebsd/" style="font-size: 15px;">freebsd</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/bash/" style="font-size: 15px;">bash</a> <a href="/tags/pkg/" style="font-size: 15px;">pkg</a> <a href="/tags/pm2/" style="font-size: 15px;">pm2</a> <a href="/tags/postgre/" style="font-size: 15px;">postgre</a> <a href="/tags/ubuntu/" style="font-size: 15px;">ubuntu</a> <a href="/tags/aws-server/" style="font-size: 15px;">aws server</a> <a href="/tags/centos-RHEL/" style="font-size: 15px;">centos RHEL</a> <a href="/tags/JavaScript-面试题/" style="font-size: 15px;">JavaScript 面试题</a> <a href="/tags/ES6-JavaScript/" style="font-size: 15px;">ES6 JavaScript</a> <a href="/tags/linux-command/" style="font-size: 15px;">linux command</a> <a href="/tags/linux-zip-tar-gz-bz2/" style="font-size: 15px;">linux zip tar gz bz2</a> <a href="/tags/news/" style="font-size: 15px;">news</a> <a href="/tags/node-js-eventloop-macrotask-microtask/" style="font-size: 15px;">node.js eventloop macrotask microtask</a> <a href="/tags/uber-api/" style="font-size: 15px;">uber api</a> <a href="/tags/redis-cluster/" style="font-size: 15px;">redis cluster</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/udp/" style="font-size: 15px;">udp</a> <a href="/tags/mac-terminal/" style="font-size: 15px;">mac terminal</a> <a href="/tags/mac-iTerm2-hostname/" style="font-size: 15px;">mac iTerm2 hostname</a> <a href="/tags/ssh-proxy/" style="font-size: 15px;">ssh proxy</a> <a href="/tags/api-server-framework/" style="font-size: 15px;">api server framework</a> <a href="/tags/redis-upstart/" style="font-size: 15px;">redis upstart</a> <a href="/tags/html5-file/" style="font-size: 15px;">html5 file</a> <a href="/tags/ubuntu-ufw/" style="font-size: 15px;">ubuntu ufw</a> <a href="/tags/ubuntu-gitlab/" style="font-size: 15px;">ubuntu gitlab</a> <a href="/tags/node-js-modules/" style="font-size: 15px;">node.js modules</a> <a href="/tags/苹果-小时候/" style="font-size: 15px;">苹果 小时候</a> <a href="/tags/ubuntu-vpn/" style="font-size: 15px;">ubuntu vpn</a> <a href="/tags/raspberry3B-ubuntu18-server-wifi/" style="font-size: 15px;">raspberry3B ubuntu18 server wifi</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/13/树莓派3B在ubuntu18-04-server上配置无线wifi/">树莓派3B在ubuntu18.04 server上配置无线wifi</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/24/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/learn-es6/">ES6新技能</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/js-basic-questions/">JavaScript 基础面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/js-interview-questions/">JavaScript 常用面试题集</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/nodejs-eventloop-macrotask-microtask/">macrotask and microtask in event loop of node.js</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/18/FreeBSD11-Config/">Configuration on FreeBSD11.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/Install-PostgreSql-on-Ubuntu16.04/">Install PostgreSql on Ubuntu16.04</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/09/install-postgresql-on-ubuntu16-04/">Install PostgreSql on Ubuntu16.04</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/ubuntu-16-04-kai-ji-zi-qi-dong-jiao-ben/">ubuntu 16.04 redis开机自启动脚本</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.ruanyifeng.com/" title="阮一峰的个人网站" target="_blank">阮一峰的个人网站</a><ul></ul><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" title="About JavaScript" target="_blank">About JavaScript</a><ul></ul><a href="https://nodejs.org/" title="Node.js" target="_blank">Node.js</a><ul></ul><a href="https://docs.mongodb.com/" title="MongoDB Docs" target="_blank">MongoDB Docs</a><ul></ul><a href="https://www.postgresql.org/" title="PostgreSQL" target="_blank">PostgreSQL</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Bin 博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>